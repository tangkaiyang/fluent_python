第21章 类元编程
类元编程是指在运行时创建或定制类的技艺.在Python中,类时一等对象,因此任何时候都可以使用函数新建类,
而无需使用class关键字.类装饰器也时函数,不过能够审查,修改,甚至把被装饰的类替换成其他类.
最后,元类是类元编程最高级的工具:使用元类可以创建具有某种特质的全新类种,例如我们见过的抽象基类
元类功能强大,但是难以掌握.类装饰器能使用更简单的方式解决很多问题.
导入时和运行时的区别--这是有效使用Python元编程的重要基础
除非开发框架,否则不要编写元类


如何在运行时创建类
21.1 类工厂函数
type视作函数type(my_object)获取对象所属的类作用于my_object.__class__相同.
然而,type是一个类.MyClass = type('MyClass', (MySuperClass, MyMinin), {'x': 42, 'x2': lambda self: self.x * 2})
三个参数为name,bases和dict(一个映射,制定新类的属性名和值)
type的实例是类
record_factory函数最后一行会构建一个类,类的名称是cls_name参数的值,唯一的直接超类是object,有
__slots__,__init__,__iter__和__repr__四个类属性,其中后三个是实例方法
本可以把__slots__类属性的名称改成其他值,不过那样就要实现__setattr__方法,
为属性赋值时验证属性的名称,因为对于记录这样的类,我们希望属性始终时固定的那几个,而且顺序相同
__slots__属性的主要特色时节省内存,能处理几百万个实例,不过也有一些缺点.
另一种方式:
先声明一个_class_template变量,其值是字符串形式的源码模板;然后在namedtuple函数中调用_class_template.format(...)方法,
填充模板里的空白;最后,使用内置的exec函数计算得到的源码字符串
!!!在Python中做元编程时,最好不用exec和eval函数.如果接受的字符串(或片段)来自不可信的源,那么这两个函数会带来严重的安全风险.
!!!Python提供了充足的内省工具,大多数时候不需要使用exec和eval函数.这样做是为了让生成的类代码能通过.source属性获取
record_factory函数创建的类,其实例有个局限--不能序列化,即不能使用pickle模块里的dump/load函数处理.


21.2 定制描述符的类装饰器
LineItem未解决的问题:储存属性的名称不具有描述性,即属性(如weight)的值存储在名为_Quantity#0的实例属性中,这样的名称有点不便于调试
不能使用描述性的储存属性名称,因为实例化描述符时无法得知托管属性(即绑定到描述符上的类属性,例如weight)的名称.
可是,一旦组建好整个类,而且把描述符绑定到类属性上之后,我们就可以审查类,并为描述符设置合理的储存属性名称.
LineItem类的__new__方法可以做到这一点,因此,在__init__方法中使用描述符时,储存属性已经设置了正确的名称.
为了解决这个问题而使用__new__方法纯属白费力气:每次新建LineItem实例时都会运行__new__方法中的逻辑,可是,一旦LineItem类构建好了,
描述符与托管属性之间的绑定就不会变了.
因此,我们要在创建类时设置储存属性的名称.使用类装饰器或元类可以做到这一点

类装饰器与函数装饰器非常相似,是参数为类对象的函数,返回原来的类或修改后的类.

示例21-3中,解释器会计算LineItem类,把返回的类对象传给model.entity函数.Python会把LineItem这个全局名称绑定给model.entity函数返回
的对象.在这个示例中,model.entity函数会返回原先的LineItem类,但是会修改各个描述符实例的storage_name属性
buldfood_v6.py
类装饰器能以较简单的方式做到以前需要使用元类去做的事情---创建类时定制类
类装饰器的重大缺点:只能对直接依附的类有效.
这意味着,被装饰的类的子类可能继承也可能不继承装饰器所做的改动,具体情况视改动的方式而定


21.3 导入时和运行时比较
Python解释器什么时候计算各个代码块
区分"导入时"和"运行时",不过这两个术语没有严格的定义,而且二者之间存在这灰色地带.
在导入时,解释器会从上到下一次性解析完.py模块的源码,然后生成用于执行的字节码.如果句法有错误,就在此时报告.
如果本地的__pycache__文件夹中有最新的.pyc文件,解释器会跳过上述步骤,因为已经有运行所需的字节码了.
编译肯定时导入时的活动,不过那个时期还会做其他事,因为Python中的语句几乎都是可执行的,也就是说语句可能会运行用户代码,
修改用户程序的状态.尤其是import语句,它不只是声明,在进程中首次导入模块时,还会运行所导入模块中的全部顶层代码---以后导入相同的
模块则使用缓存,只做名称绑定.那些顶层代码可以做任何事,包括通常在"运行时"做的事,例如连接数据库.
因此,"导入时"与"运行时"之间的界线是模糊的:import语句可以触发任何"运行时"行为.
导入时会"运行全部顶层代码",但是"顶层代码"会经过一些加工.导入模块时,解释器会执行顶层的def语句,可是这么做有什么作用呢?
解释器会编译函数的定义体(首次导入模块时),把函数对象绑定到对应的全局名称上,但是显然解释器不会执行函数的定义体.
通常这意味着解释器在导入时定义顶层函数,但是仅当在运行时调用函数时才会执行函数的定义体.
对类来说,情况就不同了:在导入时,解释器会执行每个类的定义体,甚至会执行嵌套类的定义体.执行类定义体的结果是,
定义了类的属性和方法,并构建了类对象.
从这个意义上理解,类的定义体属于"顶层代码",因为它在导入时运行.

理解计算时间的练习

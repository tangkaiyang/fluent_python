第20章属性描述符
描述符是对多个属性运用相同存取逻辑的一种方式.
描述符是实现了特定协议的类,这个协议包括__get__,__set__和__delete__方法.
property类实现了完整的描述符协议.
通常,可以只实现部分协议.其实,我们在真实的代码中见到的大多数描述符只实现了__get__和__set__方法,还有很多只实现了其中的一个
描述符是Python的独有特征,不仅在应用层中使用,在语言的基础设施中也有用到.除了特性之外,,使用描述符的Python功能还有方法及
classmethod和staticmethod装饰器.
20.1描述符示例:验证属性
特性工厂函数借助函数式编程模式避免重复编写读值方法和设值方法.特性工厂函数是高阶函数,
在闭包中存储storage_name等设置,由参数决定创建哪些存取函数,再使用存取函数构建一个特性实例.
解决这种问题的面向对象方式是描述符类
LineItem系列示例,把quantity特性工厂函数重构成Quantity描述符类
20.1.1 LineItem类第3版:一个简单的描述符
实现了__get__,__set__或__delete__方法的类就是描述符.
描述符的用法是,创建一个实例,作为另一个类的类属性
定义一个Quantity描述符,LineItem类会用到两个Quantity实例:
一个用于管理weight属性,另一个用于管理price属性.
描述符类:实现描述符协议的类,Quantity类
托管类:把描述符实例声明为类属性的类,LineItem类
描述符实例:描述符类的各个实例,声明为托管类的类属性.
托管实例:托管类的实例.LineItem实例是托管实例
储存属性:托管实例中存储自身托管属性的属性.LineItem实例的weight和price属性是储存属性.这种属性与描述符属性不同,描述符属性都是类属性
托管属性:托管类中由描述符实例处理的公开属性,值存储在储存属性中.也就是说,描述符实例和储存属性为托管属性建立了基础.
Quantity实例是LineItem类的类属性.
示例20-1 bulkfood_v3.py:
编写__set__方法时,要记住self和instance参数的意思:
self是描述符实例,instance是托管实例.
管理实例属性的描述符应该把值存储在托管实例中.
错误的做法:把各个托管属性的值直接存在描述符实例中:
self.__dict__[self.storage_name] = value
应为    instance.__dict__[self.storage_name] = value
self是描述符实例,其实是托管类的类属性.同一时刻,内存中可能有几千个LineItem实例,不过只会有两个描述符实例:LineItem.weight和LineItem.price
因此,存储在描述符实例中的数据,其实会变成LineItem类的类属性,从而由全部LineItem实例共享
示例20-1有个缺点,在托管类的定义体中实例化描述符时要重复输入属性的名称.
实现:
class LineItem:
    weight = Quantity()
    price = Quantity()
可问题是,正如第8章所说的,赋值语句右手边的表达式先执行,而此时变量还不存在.
Quantity()表达式计算的结果是创建描述符实例,而此时Quantity类中的代码无法猜出要把描述符绑定给哪个变量
因此,示例20-1必须明确指明各个Quantity实例的名称.
这样不仅麻烦,还很危险:如果程序员直接复制粘贴代码而忘了编辑名称,
比如写成price = Quantity('weight'),那么程序的行为就会大错特错,设置price的值时会覆盖weight的值


不太优雅但是可行的方案(更好的方案是使用装饰器或元类)
20.1.2 LineItem类第4版:自动获取储存属性的名称
将每个Quantity实例的storage_name属性生成一个独一无二的字符串.
为了生成storage_name,以'_Quantity#'为前缀,然后在后面拼接一个整数:Quantity.__counter类属性的当前值,每次把一个新的Quantity描述符实例
依附到类上,都会递增这个值.
在前缀中使用井号能避免storage_name与用户使用点号创建的属性冲突,因为nutmeg._Quantity#0是无效的Python句法.
但是,内置的getattr和setattr函数可以使用这种"无效"的标识符获取和设置属性,此外也可以直接处理实例属性__dict__.
示例20-2 bulkfood_v4.py
这里可以使用内置的高阶函数getattr和setattr存取值,无需使用instance.__dict__,因为托管属性和储存属性的名称不同,
所以把储存属性传给getattr函数不会触发描述符,不会像20-1那样出现无限递归.
如果想使用Python矫正名称的约定方式(例如_LineItem__quantity0),
要知道托管类(即LineItem)的名称,可是,解释器要先运行类的定义体才能构建类,因此创建描述符实例时得不到那个信息.
不过,对这个示例来说,为了防止不小心被子类覆盖,不用包含托管类的名称,因为每次实例化新的描述符,描述符类的__counter属性都会递增,
从而确保每个托管类的每个储存属性的名称都是独一无二的
注意,__get__方法有三个参数:self,instance和owner.
owner参数是托管类(如LineItem)的引用,通过描述符从托管类中获取属性时用得到.
如果使用LineItem.weight从类中获取托管属性(以weight为例),描述符的__get__方法接收到的instance参数值是None.
因此,下述控制台会话才会抛出AttributeError异常:
此外,为了给用户提供内省和其他元编程技术支持,通过类访问托管属性时,最好让__get__方法返回描述符实例.
示例20-3 bulkfood_v4b.py
描述符逻辑现在被抽象到单独的代码单元(Quantity类)中了.通常,我们不会在使用描述符的模块中定义描述符,而是
在一个单独的使用工具模块中定义,以便在整个应用中使用--如果开发的是框架,甚至会在多个应用中使用
示例20-4 bulkfood_v4c.py 描述符的常规用法
Django模型的字段就是描述符
唯一的缺点:储存属性的名称是生成的(如_Quantity#0),导致用户难以调试.
但是这是不得已而为之,如果想自动把储存属性的名称设成与托管属性的名称类似,需要用到类装饰器或元类
描述符在类中定义,因此可以利用继承重用部分代码来创建新描述符
特性工厂函数与描述符类比较
特性工厂函数若想实现示例20-2中增强的描述符类并不难,只需在示例19-24的基础上添加几行代码.
__counter变量的实现方式是个难点,不过我们可以把它定义成工厂函数对象的属性,以便在多次调用之间持续存在,
示例20-5 bulkfood_v4prop.py
描述符类的两个优点:
# 描述符类可以使用子类扩展;若想重用工厂函数中的代码,除了复制粘贴,很难有其他方法
# 与示例20-5中使用函数属性和闭包保持状态相比,在类属性和实例属性中保持状态更易于理解
特性工厂函数的代码不依赖奇怪的对象关系,而描述符的方法中有名为self和instance的参数,表明里面涉及奇怪的对象关系
总之,从某种程度上来讲,特性工厂函数模式较简单,可以描述符类方式更易扩展,而且应用也更广泛

20.1.3 LineItem类第5版:一种新型描述符
有商品的描述信息为空,导致无法下订单.
为了避免出现这个问题,创建一个描述符,NonBlank
与Quantity描述符很像,只是验证逻辑不通
Quantity功能:管理托管实例中的储存属性,以及验证用于设置那两个属性的值.
重构,并创建两个基类
AutoStorage:自动管理储存属性的描述符类
Validated:扩展AutoStorage类的抽象子类,覆盖__set__方法,调用必须由子类实现的validate方法.
AutoStorage基类负责自动存储属性;Validated类做验证,把职责委托给抽象方法validata;Quantity和NonBlank是Validated的具体子类
Validated,Quantity和NonBlank三个类之间的关系体现了模板方法设计模式.
Validated.__set__方法正式模板方法的例证:
    一个模板方法用一些抽象的操作定义一个算法,而子类将重定义这些操作以提供具体的行为
这里,抽象的操作的验证
示例20-6 model_v5.py
model_v5.py脚本的用户不需要知道全部细节.用户只需知道,他们可以使用Quantity和NonBlank自动验证实例属性.
示例20-7 bulkfood_v5.py
本章所列举的几个LineItem示例演示了描述符的典型用途--管理数据属性.
这种描述符也叫覆盖型描述符,因为描述符的__set__方法使用托管实例中的同名属性覆盖(即插手接管)了要设置的属性.
不过,也有非覆盖型描述符
20.2 覆盖型与非覆盖型描述符对比
Python存取属性的方式特别不对等.
通过实例读取属性时,通常返回的是实例中定义的属性;
但是,如果实例中没有指定的属性,那么会获取类属性.
而为实例中的属性赋值时,通常会在实例中创建属性,根本不影响类
这种不对等的处理方式对描述符也有影响.
其实,根据是否定义__set__方法,描述符可分为两大类.
在示例20-8中,每个__get__和__set__方法都调用了print_args函数,使调用方式易于阅读.没有必要深入理解
print_args函数及辅助函数cls_name和display.
示例20-8 descriptorkinds.py

分析对Managed类(托管类)及其实例做属性读写的行为,以及讨论所定义的各个描述符
20.2.1 覆盖型描述符
实现__set__方法的描述符属于覆盖型描述符,因为虽然描述符是类属性,但是实现__set__方法的话,
会覆盖对实例属性的赋值操作.示例20-2就是这样实现的.特性也是覆盖型描述符:
如果没有提供设值函数,property类中的__set__方法会抛出AttributeError异常,指明那个属性是只读的.
示例20-9 descriptorkinds.py
20.2.2 没有__get__方法的覆盖型描述符
覆盖型描述符可以只实现__set__方法,此时,只有写操作由描述符处理.
通过实例读取描述符会返回描述符对象本身,因为没有处理读操作的__get__方法.
如果直接通过实例的__dict__属性创建同名实例属性,以后再设置那个属性时,仍会由__set__方法插手接管,
但是读取那个属性的话,就会直接从实例中返回新赋予的值,而不会返回描述符对象.
也就是说,实例属性会遮盖描述符,不过只有读操作是如此
示例20-10 descriptorkinds.py
20.2.3 非覆盖型描述符
没有实现__set__方法的描述符就是非覆盖型描述符.
如果设置了同名的实例属性,描述符会被遮盖,致使描述符无法处理那个实例的那个属性.
方法是以非覆盖型描述符实现的.
示例20-11 descriptorkinds.py
覆盖型描述符也叫数据描述符或强制描述符.
非覆盖型描述符也叫非数据描述符或遮盖型描述符
20.2.4 在类中覆盖描述符
不管描述符是不是覆盖型,为类属性赋值都能覆盖描述符.
这是一种猴子补丁技术
示例20-12 descriptorkinds.py
示例20-12揭示了读写属性的另一种不对等:
读类属性的操作可以由依附在托管类上定义有__get__方法的描述符处理,但是写类属性的操作不会由依附在托管类上定义有__set__方法的描述符处理
若想控制设置类属性的操作,要把描述符依附在类的类上,即依附在元类上.
默认情况下,对用户定义的类来说,其元类是type,而我们不能为type添加属性.可以自己创建元类


Python是如何使用描述符实现方法的
20.3 方法是描述符
在类中定义的函数属于绑定方法(bound method),因为用户定义的函数都有__get__方法,所以依附到类上时,就相当于描述符.
示例20-13 descriptorkinds.py
函数没有实现__set__方法,因此是非覆盖型描述符.
一个重要信息:obj.spam和Managed.spam获取的是不同的对象.与描述符一样,通过托管类访问时,
函数的__get__方法会返回自身的引用.但是,通过实例访问时,函数的__get__方法返回的是绑定方法对象:
一种可调用的对象,里面包装这函数,并把托管实例(例如obj)绑定给函数的第一个参数(即self),这与functools.partial函数行为一致
示例20-14 method_is_descriptor.py
绑定方法对象还有个__call__方法,用于处理真正的调用过程.
这个方法会调用__func__属性引用的原始函数,把函数的第一个参数设为绑定方法的__self__属性.这就是形参self的隐式绑定方式
函数会变成绑定方法,这是Python语言底层使用描述符的最好例证


20.4 描述符用法建议
使用特性以保持简单
    内置的property类创建的其实是覆盖型描述符,__set__方法和__get__方法都实现了,即便不定义设值方法也是如此.
    特性的__set__方法默认抛出AttributeError: can't set attribute,
    因此创建只读属性最简单的方式是使用特性,这能避免下一条所述的问题
只读描述符必须有__set__方法
    如果使用描述符类实现只读属性,要记住,__get__和__set__两个方法必须都定义,否则,实例的同名属性会遮盖描述符.
    只读属性的__set__方法只需抛出AttributeError异常,并提供合适的错误消息
用于验证的描述符可以只有__set__方法
    对仅用于验证的描述符来说,__set__方法应该检查value参数获得的值,如果有效,使用描述符实例的名称为键,直接在实例的
    __dict__属性中设置.这样,从实例中读取同名属性的速度很快,因为不用经过__get__方法处理
仅有__get__方法的描述符可以实现高效缓存
    如果只编写了__get__方法,那么创建的是非覆盖型描述符.这种描述符可用于执行某些耗费资源的计算,然后为实例设置同名属性,
    缓存结果.同名实例属性会遮盖描述符,因此后续访问会直接从实例的__dict__属性中获取值,而不会再触发描述符的__get__方法.
    非特殊的方法可以被实例属性遮盖
非特殊的方法可以被实例属性遮盖
    由于函数和方法只实现了__get__方法,他们不会处理同名实例属性的赋值操作.
    因此,像my_obj.the_method = 7这样简单赋值之后,后续通过该实例访问the_method得到的是数字7--但是不影响类或其他实例.
    然而,特殊方法不受这个问题的影响.解释器只会在类中寻找特殊的方法,也就是说,repr(x)执行的其实是
    x.__class__.__repr__(x),因此x的__repr__属性对repr(x)方法调用没有影响.
    出于同样的原因,实例的__getattr__属性不会破坏常规的属性访问原则
    实例的非特殊方法可以被轻松地覆盖,这听起来不可靠且容易出错(其实没关系?作者觉得)
    然而,如果要创建大量动态属性,属性名称从不受自己控制的数据中获取,那么你应该知道这种行为;
    或许你还可以实现某种机制,过滤或转义动态属性的名称,以维持数据的健全性

示例19-6中的FrozenJSON类不会出现实例属性遮盖方法的问题,因为那个类只有几个特殊方法和一个build类方法.
只要通过类访问,类方法就是安全的,在示例19-6中就是这么调用FrozenJSON.build方法的--在示例19-7中替换成__new__方法了.
Record类及其子类也是安全的,因为只用到了特殊的方法,类方法,静态方法和特性.特性是数据描述符,因此不能被实例属性覆盖.


20.5 描述符的文档字符串和覆盖删除操作
__get__和__set__之外,可以实现__delete__方法,或者只实现__delete__方法,删除托管属性

20.6 本章小结
Python中特性attribute
# 特性是对象内部的变量
# 对象的状态由它的特性来描述,对象的方法可以改变它的特性
# 可以直接从对象外部访问特性
特性示例
class Person:
    name = 'yoda' # 类中特性
    def get_name(self): # 通过访问器方法访问特性
        return self.name
    def set_name(self, value): # 通过访问器方法改变特性
        self.name = value
运行:
A1 = Person()
A1.name # 直接从外部访问特性
A1.name = 'master' # 直接从外部改变特性
Python中私有化特性:为了让外部无法访问特性或方法,只要在名字前面加上双下划线即可
特性私有化示例:
class Secret:
    __name = 'yoda' # 加上双下划线私有化特性
    def get_name(self):
        return self.__name
    def __secret(self): # 私有化方法
        print("can't find")
    def access(self):
        return self.__secret() # 访问器访问私有方法
A2 = Secret()
A2.__name # 访问不到特性!
A2._Secret__name  # 还是可以从外部访问特性
Python中使用属性(property)对特性进行访问和设置
# 有一些面向对象语言支持私有特性,这些特性无法从外部直接访问,需要编写getter和setter方法对这些特性进行操作
# Python不需要getter和setter方法,因为Python中所有特性都是公开的,如果不放心使用直接访问对象的特性,可以为对象编写
setter和getter方法,但是更好的解决方法是使用属性(property)
# Python隐藏访问器的方法,让所有特性看起来一样,这种通过访问器定义的特性被称为属性
属性使用示例
# 第一种方法使用属性
class foo:
    def __init__(self):
        self.name = 'yoda'
        self.work = 'master'

    def get_person(self):
        return self.name, self.work
    def set_person(self, value):
        self.name, self.work = value
    person = property(get_person, set_person)
# 第二种方法使用属性
class foo:
    def __init__(self):
        self.name = 'yoda'
        self.work = 'master'
    @property
    def person(self):
        return self.name, self.work
    @person.setter
    def person(self, value):
    self.name, self.work = value
# property()第一个参数是getter方法,第二个参数是setter方法
# propety函数可以用0,1,2,3或4个参数来调用,如果没有参数,产生的属性既不可读,也不可写,这四个参数分别叫做
fget,fset,fel,fdoc,如果想要一个属性是可写的,并且有一个文档字符串,能使用他们作为关键字参数
第12章 继承的优缺点
推出继承的初衷是让新手顺利使用只有专家才能设计出来的框架

本章探讨继承和子类化
子类化内置类型的缺点
多重继承和方法解析顺序

GUI工具包Tkinter
Web框架Django
12.1 子类化内置类型很麻烦
内置类型不会调用用户定义的类覆盖的特殊方法
示例12-1 内置类型dict的__init__和__update__方法会忽略我们覆盖的__setitem__方法
[]运算符会调用我们覆盖的__setitem__方法
原生类型的这种行为违背了面向对象编程的一个基本原则:始终应该从实例(self)所属的类开始搜索方法,
即使在超类实现的类中调用也是如此.
__missing__方法能按预期方式工作,不过这是特例
__missing__方法只会被__getitem__调用(d[k])
所有的映射类型在处理找不到的键的时候,都会牵扯到__missing__方法
不只实例内部的调用有这个问题(self.get()不调用self.__getitem__()),
内置类型的方法调用的其他类的方法,如果被覆盖了,也不会被调用
示例12-2 dict.update方法会忽略AnswerDict.__getitem__方法
直接子类化内置类型(如dict,list或str)容易出错,因为内置类型的方法通常会忽略用户覆盖的方法.
不要子类化内置类型,用户自己定义的类应该继承collections模块中的类,
例如,UserDict, UserList和UserString,这些类做了特殊设计,因此易于扩展
如果不子类化dict,而是子类化collections.UserDict,
问题便不存在了
示例12-3 对12-1,12-2修改
综上,本节所述的问题只发生在C语言实现的内置类型内部的方法委托上,而且只影响直接继承内置类型的用户自定义类.
如果子类化使用Python编写的类,如UserDict或MutableMapping,就不会受此影响

与继承,尤其是多重继承有关的另一个问题:如果同级别的超类定义了同名属性,Python如何确定使用哪一个
12.2 多重继承和方法解析顺序
任何实现多继承的语言都要处理潜在的命名冲突,这种冲突由不相关的祖先类实现同名方法引起.
这种冲突称为"菱形冲突"
示例12-4:diamond.py
注意,B和C都实现了pong方法,二者唯一的区别是,C.pong方法输出的是大写的PONG
在D的实例上调用d.pong()方法的话,运行的是哪个pong方法呢?
C++中,必须使用类名限定方法调用来避免这种歧义.
Python也能这么做
示例12-5: 在D实例上调用pong方法的两种方式
直接调用d.pong()运行的是B类中的版本(B.pong(d))
超类中的方法都可以直接调用,此时要把实例作为显式参数传入(C.pong(d))
Python能区分d.pong()调用的是哪个方法,是因为Python会按照特定的顺序遍历继承图.
这个顺序叫做方法解析顺序(Method Resolution Order, MRO).
类都有一个名为__mro__的属性,它的值是一个元组,按照方法解析顺序列出各个超类,从当前类一直向上,直到object类
若想把方法委托给超类,推荐的方式是使用内置的super()函数.
有时需要绕过方法解析顺序,直接调用某个超类的方法
def ping(self):
    A.ping(self) # 而不是super().ping()
    print('post-ping:', self)
注意,直接在类上调用实例方法时,必须显示传入self参数,因为这样访问的是未绑定方法(unbound method)
然而,使用super()最安全,也不易过时.调用框架或不受自己控制的类层次结构中的方法时,尤其适合使用super().
使用super()调用方法时,会遵守方法解析顺序
示例12-6 使用super()函数调用ping方法
示例12-7 pingpong方法的5个调用
方法解析顺序不仅考虑继承图,还考虑子类声明中列出超类的顺序.
如果在diamond.py文件中把D类声明为class D(C, B):,那么D类的__mro__属性就会不一样:
示例12-8 查看几个类的__mro__属性
方法解析顺序使用C3算法计算:除非大量使用多继承,或者继承关系不同寻常,否则不用了解C3算法,

12.3 多重继承的真实应用
多重继承能发挥积极作用
适配器模式
在标准库中,GUI工具包Tkinter(tkinter模块是Tcl/Tk的Python接口)把多重继承用到了极致.
12.4 处理多重继承
01.把接口继承和实现继承区分开
使用多重继承时,一定要明确一开始为什么创建子类.主要原因可能有:
继承接口,创建子类型,实现"是什么"关系
继承实现,通过重用避免代码重复
通过继承重用代码是实现细节,通常可以换用组合和委托模式.
而接口继承是框架的支柱
02.使用抽象基类显式表示接口
如果类的作用是定义接口,应该明确把它定义为抽象基类
03.通过混入重用代码
如果一个类的作用是为多个不相关的子类提供方法实现,从而实现重用,但不体现"是什么"关系,应该把那个类明确地定义为混入类
(mixin class).从概念上讲,混入不定义新类型,只是打包方法,便于重用.混入类绝对不能实例化,而且具体类不能只继承混入类.
混入类应该提供某方面的特定行为,只实现少量关系非常紧密的方法

第15章 上下文管理器和else块
with语句和上下文管理器
for,while和try语句的else子句
with语句会设置一个临时的上下文,交给上下文管理器对象控制,并且负责清理上下文.
这么做能避免错误并减少样板代码,因此API更安全,而且更易于使用.
else子句与with语句完全没有关系.
15.1 先做这个,再做那个:if语句之外的else块
else子句不仅能在if语句中使用,还能在for,while和try语句中使用
for/else,while/else和try/else的语义关系紧密,
不过与if/else差别很大.
else子句的行为如下.
for:仅当for循环运行完毕时(即for循环没有被break语句中止)才运行else块
while:仅当while循环因为条件为假值而退出时(即while循环没有被break语句中止)才运行else块
try:仅当try块中没有异常抛出时才运行else块.
else子句抛出的异常不会由前面的except子句处理
在所有情况下,如果异常或者return,break或continue语句导致控制权跳到了符合语句的主块之外,
else子句也会被跳过


强大的with语句
15.2 上下文管理器和with块
上下文管理器协议包含__enter__和__exit__两个方法.
执行with后面的表达式得到的结果是上下文管理器对象,不过把值绑定到目标变量上(as子句)是在上下文
管理器对象上调用了__enter__方法的结果
碰巧,open()函数返回TextIOWrapper类的实例,而该实例的__enter__方法返回self.
不过__enter__方法除了返回上下文管理器之外,还可能返回其他对象.
不管控制流程以哪种方式退出with块,都会在上下文管理器对象上调用__exit__方法,而不是在
__enter__方法返回的对象上调用
示例15-2 使用一个精心制作的上下文管理器执行操作,以此强调上下文管理器与__enter__方法返回的对象之间的区别
lookingglass_test.py
示例15-3 LookingGlass类的实现
mirror.py
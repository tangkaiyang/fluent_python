第六部分 元编程
第19章 动态属性和特性
特性至关重要的地方在于,特性(property)的存在使得开发者可以非常安全并且确定可行地将公共数据属性作为类的公共接口的一部分开放出来.
在Python中,数据的属性和处理数据的方法统称为属性(attribute).
其实,方法只是可调用的属性.
除了这二者之外,我们还可以创建特性(property),在不改变类接口的前提下,使用存取方法(即读值方法和设值方法)修改数据属性
这与统一访问原则相符:
不管服务是由存储还是计算实现的,一个模块提供的所有服务都应该通过统一的方式使用.
除了特性,Python还提供了丰富的API,用于控制属性的访问权限,以及实现动态属性.
使用点号访问属性时(如obj.attr),Python解释器会调用特殊的方法(如__getattr__和__setattr__)计算属性.
用户自己定义的类可以通过__getattr__方法实现"虚拟属性",当访问不存在的属性时(如obj.no_such_attribute),即时计算属性的值
动态创建属性是一种元编程,框架的作者经常这么做.
19.1 使用动态属性转换数据
使用动态属性处理JSON格式数据源.
示例19-1 asconfeed.json文件中的记录示例:
示例19-2 osconfeed.py:下载osconfeed.json
19.1.1 使用动态属性访问JSON类数据
实现FrozenJSON类,只支持读取,即只能访问数据.
这个类能递归,自动处理嵌套的映射和列表
示例19-4演示FrozenJSON类的用法
FrozenJSON类的关键是__getattr__方法.
仅当无法使用常规方式获取属性(即在实例,类或超类中找不到指定属性),解释器才会调用特殊的__getattr__方法
理论上,尝试读取不存在的属性应该抛出AttributeError异常.
如示例19-5所示,FrozenJSON类只有两个方法(__init__和__getattr__)和一个实例属性__data.
因此,尝试获取其他属性会触发解释器调用__getattr__方法.这个方法首先查看self.__data字典有没有指定名称的属性(不是键)
这样FrozenJSON实例便可以处理字典的所有方法,例如把items方法委托给self.__data.items()方法.
如果self.__data没有指定名称的属性,那么__getattr__方法以那个名称为键,从self.__data中读取一个元素,
传给FrozenJSON.build方法.这样就能深入JSON数据的嵌套结构,使用类方法build把每一层嵌套转换成一个FrozenJSON实例
示例19-5 explore0.py:把一个JSON数据集转换成一个嵌套这FrozenJSON对象,列表和简单类型的FrozenJSON对象.
注意,我们没有从缓存或转换原始数据源.在迭代数据源的过程中,嵌套的数据结构不断被转换成FrozenJSON对象.
这么做没问题,因为数据集不大,而且这个脚本只用于访问或转换数据
从随机数据源中生成或效仿动态属性名的脚本都必须处理同一个问题:
原始数据中的键可能不适合作为属性名
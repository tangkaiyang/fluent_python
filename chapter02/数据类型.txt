容器序列
list,tuple和collecitons.deque能存放不同类型的数据
扁平序列
str,bytes,bytearray,memoryview和array.array只能容纳一种类型.
容器徐磊存放的是它们所包含的任意类型的对象的引用,
而扁平序列里存放的是值而不是引用.
扁平序列其实是一段连续的内存空间.更加紧凑,只能存放诸如字符,字节和数值这种基础类型

可变序列(MutableSequence):list,bytearray,array.array,collections.deque和memoryview
不可变序列(Sequence):tuple,str和bytes

Python会忽略代码里的[], {}和()中的换行,
列表推导式不会再有变量泄露的问题

笛卡尔积
笛卡尔积是一个列表,列表里的元素是由输入的可迭代类型的元素对构成的元组,
因此笛卡尔积列表的长度等于输入变量的长度的乘积
colors = ['black', 'white']
sizes = ['S', 'M', 'L']
tshirts = [(color, size) for color in colors for size in sizes]
更换输出顺序只需要调整从句顺序,for循环嵌套顺序一致
列表推导式-->生成列表
生成器表达式-->其他类型的序列
列表推导式可以初始化元组,数组或者其他序列类型,
但是生成器表达式是更好的选择
因为生成器表达式遵守了迭代器协议,可以逐个产出元素,而不是建立一个完整的列表,
然后再把这个列表传递到某个构造函数里.节省了内存
[] --> ()
实例2.5
用生成器表达式初始化元组和数组
symbols = '$fdj'
tuple(ord(symbol) for symbol in symbols)
import array
array.array('I', (ord(symbol) for symbol in symbols))
array(...)
如果生成器表达式是一个函数调用过程中的唯一参数,那么不需要额外用括号围起来
array的构造方法需要两个参数,因此括号是必须的.array构造方法的第一个参数指定了数组中数字的存储方式

2.3元组不仅仅是不可变的列表
还可以用于没有字段名的记录
2.3.1 元组和记录
元组其实是对数据的记录:
元组中的每个元素都存放了记录中一个字段的数据,外加这个字段的位置.正是这个位置信息给数据赋予了意义.
2.3.2 元组拆包
元组拆包可以应用到任何可迭代对象上,
唯一的硬性要求是,被可迭代对象中的元素数量必须要跟接受这些元素的元组的空档数一致.
除非我们用*表示忽略多余的元素,
最好辨认的元组拆包形式是平行赋值,也就是说把一个可迭代对象里的元素,一并赋值到由对应的变量组成的元组中.
lax_coordinates = (33.9425, -118.408056)
latitude, longitude = lax_coordinates # 元组拆包
不使用中间变量交换两个变量的值:
b, a = a, b
用*运算符把一个可迭代对象拆开作为函数的参数:
divmod(20, 8) -> (2, 4)
t = (20, 8)
divmod(*t) -> (2, 7)
quotient, remainder = divmod(*t)
元组拆包让一个函数可以用元组的形式返回多个值,然后调用函数的代码就能轻松地接受这些返回值.
如:os.path.split()函数会返回以路径和最后一个文件名组成的元组
(path, last_part)
import os
_, filename = os.path.split('/home/luciano/.ssh/idrsa.pub')
filename -> 'idrsa.pub'
在进行拆包的时候,不总对元组里所有的数据都感兴趣,
_占位符能帮助处理这种情况
注意:如果做的是国际化软件,那么_可能就不是一个理想的占位符,
因为它也是gettext.gettext函数的常用别名,
元组拆包中使用*也可以帮助我们把注意力集中在元组的部分元素上.
在Python中,函数用*args来获取不确定数量的参数.
在Python3中,这个概念被扩展到了平行赋值中:
a, b, *rest = range(5)
a, b, rest --> (0, 1, [2, 3, 4])
a, b, *rest = range(3)
a, b, rest --> (0, 1, [2])
a, b, *rest = range(2)
a, b, rest --> (0, 1, [])
在平行赋值中,*前缀只能用在一个变量名前面,但是这个变量可以出现在赋值表达式的任意位置:
a, *body, c, d = range(5)
a, body, c, d --> (0, [1, 2], 3, 4)
*head, b, c, d = range(5)
head, b, c, d --> ([0, 1], 2, 3, 4)

2.3.3 嵌套元组拆包
接受表达式的元组可以是嵌套式的,
例如(a, b, (c, d)).
只要这个接受元组的嵌套结构符号表达式本身的嵌套结构,就可以做出正确的对应.
在Python3之前,元组可以作为形参放在函数声明中,
例如def fn(a, (b, c), d):
然而Python3不再支持这种格式,
我们时常会需要给记录中的字段命名.
namedtuple函数的出现帮我们结局了这问题

2.3.4 具名元组
collections.namedtuple是一个工厂函数,
它可以用来构建一个带字段名的元组和一个有名字的类
这个带名字的类对调试程序有很大帮助
用namedtuple构建的类的实例锁消耗的内存跟元组是一样的,
因为字段名都被存在对应的类里面.
这个实例跟普通的对象实例比起来要小一些,因Python不会用__dict__来存放这些实例的属性.
例:新建Card类:
Card = collections.namedtuple('Card', ['rank', 'suit'])

创建一个具名元组需要两个参数,一个是类名,另一个是类的各个字段的名字.
后者可以是由数个字符组成的可迭代对象,或者由空格分隔开的字段名组成的字符串
存放在对应字段里的数据要以一串参数的形式传入到构造函数中(注意,元组的构造函数却只接受单一的可迭代对象)
你可以通过字段名或者位置来获取一个字段的信息

除了从普通元组那里继承来的属性之外,具名元组还有一些自己专用的属性.
_fields类属性,类方法__make(iterable)和实例方法_asdict()

_fields属性是一个包含这个类所有字段名称的元组
用_make()通过接受一个可迭代对象来生成这个类的一个实例,
它的作用跟City(*delhi_data)是一样的
_asdict()把具名元组以collections.OrderedDict的形式返回,
我们可以利用他来把元组里的信息友好地呈现出来.

2.3.5 作为不可变列表的元组
除了跟增减元素相关的方法之外,元组支持列表的其他所有方法.
还有一个例外,元组没有__reversed__方法
这个方法只是个优化而已,reversed(my_tuple)这个用法在没有__reversed__的情况下也是合法的.


2.4 切片
2.4.1 为什么切片和区间会忽略最后一个元素
下标从0作为起始的好处:
当只有最有一个位置信息时,我们也可以快速看出切片和区间里有几个元素:
range(3)和my_list[:3]都返回3个元素
当起止位置信息都可见时,我们可以快速计算出切片和区间的长度,
用后一个数减去第一个下标(stop-start)即可
这样做也让我们可以利用任意一个小标来把序列分割成不重叠的两部分,
只要写成my_list[:x]和my_list[x:]就可以了

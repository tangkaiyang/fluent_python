容器序列
list,tuple和collecitons.deque能存放不同类型的数据
扁平序列
str,bytes,bytearray,memoryview和array.array只能容纳一种类型.
容器徐磊存放的是它们所包含的任意类型的对象的引用,
而扁平序列里存放的是值而不是引用.
扁平序列其实是一段连续的内存空间.更加紧凑,只能存放诸如字符,字节和数值这种基础类型

可变序列(MutableSequence):list,bytearray,array.array,collections.deque和memoryview
不可变序列(Sequence):tuple,str和bytes

Python会忽略代码里的[], {}和()中的换行,
列表推导式不会再有变量泄露的问题

笛卡尔积
笛卡尔积是一个列表,列表里的元素是由输入的可迭代类型的元素对构成的元组,
因此笛卡尔积列表的长度等于输入变量的长度的乘积
colors = ['black', 'white']
sizes = ['S', 'M', 'L']
tshirts = [(color, size) for color in colors for size in sizes]
更换输出顺序只需要调整从句顺序,for循环嵌套顺序一致
列表推导式-->生成列表
生成器表达式-->其他类型的序列
列表推导式可以初始化元组,数组或者其他序列类型,
但是生成器表达式是更好的选择
因为生成器表达式遵守了迭代器协议,可以逐个产出元素,而不是建立一个完整的列表,
然后再把这个列表传递到某个构造函数里.节省了内存
[] --> ()
实例2.5
用生成器表达式初始化元组和数组
symbols = '$fdj'
tuple(ord(symbol) for symbol in symbols)
import array
array.array('I', (ord(symbol) for symbol in symbols))
array(...)
如果生成器表达式是一个函数调用过程中的唯一参数,那么不需要额外用括号围起来
array的构造方法需要两个参数,因此括号是必须的.array构造方法的第一个参数指定了数组中数字的存储方式

2.3元组不仅仅是不可变的列表
还可以用于没有字段名的记录
2.3.1 元组和记录
元组其实是对数据的记录:
元组中的每个元素都存放了记录中一个字段的数据,外加这个字段的位置.正是这个位置信息给数据赋予了意义.
2.3.2 元组拆包
元组拆包可以应用到任何可迭代对象上,
唯一的硬性要求是,被可迭代对象中的元素数量必须要跟接受这些元素的元组的空档数一致.
除非我们用*表示忽略多余的元素,
最好辨认的元组拆包形式是平行赋值,也就是说把一个可迭代对象里的元素,一并赋值到由对应的变量组成的元组中.
lax_coordinates = (33.9425, -118.408056)
latitude, longitude = lax_coordinates # 元组拆包
不使用中间变量交换两个变量的值:
b, a = a, b
用*运算符把一个可迭代对象拆开作为函数的参数:
divmod(20, 8) -> (2, 4)
t = (20, 8)
divmod(*t) -> (2, 7)
quotient, remainder = divmod(*t)
元组拆包让一个函数可以用元组的形式返回多个值,然后调用函数的代码就能轻松地接受这些返回值.
如:os.path.split()函数会返回以路径和最后一个文件名组成的元组
(path, last_part)
import os
_, filename = os.path.split('/home/luciano/.ssh/idrsa.pub')
filename -> 'idrsa.pub'
在进行拆包的时候,不总对元组里所有的数据都感兴趣,
_占位符能帮助处理这种情况
注意:如果做的是国际化软件,那么_可能就不是一个理想的占位符,
因为它也是gettext.gettext函数的常用别名,
元组拆包中使用*也可以帮助我们把注意力集中在元组的部分元素上.
在Python中,函数用*args来获取不确定数量的参数.
在Python3中,这个概念被扩展到了平行赋值中:
a, b, *rest = range(5)
a, b, rest --> (0, 1, [2, 3, 4])
a, b, *rest = range(3)
a, b, rest --> (0, 1, [2])
a, b, *rest = range(2)
a, b, rest --> (0, 1, [])
在平行赋值中,*前缀只能用在一个变量名前面,但是这个变量可以出现在赋值表达式的任意位置:
a, *body, c, d = range(5)
a, body, c, d --> (0, [1, 2], 3, 4)
*head, b, c, d = range(5)
head, b, c, d --> ([0, 1], 2, 3, 4)

2.3.3 嵌套元组拆包
接受表达式的元组可以是嵌套式的,
例如(a, b, (c, d)).
只要这个接受元组的嵌套结构符号表达式本身的嵌套结构,就可以做出正确的对应.
在Python3之前,元组可以作为形参放在函数声明中,
例如def fn(a, (b, c), d):
然而Python3不再支持这种格式,
我们时常会需要给记录中的字段命名.
namedtuple函数的出现帮我们结局了这问题

2.3.4 具名元组
collections.namedtuple是一个工厂函数,
它可以用来构建一个带字段名的元组和一个有名字的类
这个带名字的类对调试程序有很大帮助
用namedtuple构建的类的实例锁消耗的内存跟元组是一样的,
因为字段名都被存在对应的类里面.
这个实例跟普通的对象实例比起来要小一些,因Python不会用__dict__来存放这些实例的属性.
例:新建Card类:
Card = collections.namedtuple('Card', ['rank', 'suit'])

创建一个具名元组需要两个参数,一个是类名,另一个是类的各个字段的名字.
后者可以是由数个字符组成的可迭代对象,或者由空格分隔开的字段名组成的字符串
存放在对应字段里的数据要以一串参数的形式传入到构造函数中(注意,元组的构造函数却只接受单一的可迭代对象)
你可以通过字段名或者位置来获取一个字段的信息

除了从普通元组那里继承来的属性之外,具名元组还有一些自己专用的属性.
_fields类属性,类方法__make(iterable)和实例方法_asdict()

_fields属性是一个包含这个类所有字段名称的元组
用_make()通过接受一个可迭代对象来生成这个类的一个实例,
它的作用跟City(*delhi_data)是一样的
_asdict()把具名元组以collections.OrderedDict的形式返回,
我们可以利用他来把元组里的信息友好地呈现出来.

2.3.5 作为不可变列表的元组
除了跟增减元素相关的方法之外,元组支持列表的其他所有方法.
还有一个例外,元组没有__reversed__方法
这个方法只是个优化而已,reversed(my_tuple)这个用法在没有__reversed__的情况下也是合法的.


2.4 切片
2.4.1 为什么切片和区间会忽略最后一个元素
下标从0作为起始的好处:
当只有最有一个位置信息时,我们也可以快速看出切片和区间里有几个元素:
range(3)和my_list[:3]都返回3个元素
当起止位置信息都可见时,我们可以快速计算出切片和区间的长度,
用后一个数减去第一个下标(stop-start)即可
这样做也让我们可以利用任意一个小标来把序列分割成不重叠的两部分,
只要写成my_list[:x]和my_list[x:]就可以了
2.4.2 对对象进行切片
可以用s[a: b: c]形式对s在a和b之间以c为间隔取值.c可以为负,意味着反向取值.
s = 'bicycle'
s[::3] --> 'bye'
s[::-1] --> 'elcyclib'
s[::-2] --> 'eccb'
对seq[start:stop:step]进行求值的时候,
Python会调用seq.__getitem__(slice(start, stop, step)).

2.4.3 多维切片和省略
[]运算符里还可以使用以逗号分开的多个索引或者是切片,
要正确处理这种[]运算符的话,对象的特殊方法__getitem__和__setitem__
需要以元组的形式来接受a[i, j]中的索引.
也就是说要得到a[i, j]的值,Python会调用a.__getitem__((i, j))
Python内置的序列类型都是一维的,因此它们只支持单一的索引,成对出现的索引是没有用的.
省略(ellipsis)的正确书写方法是三个英文句号...,
而不是Unicode码位U+2026表示的半个省略号.
省略在Python解释器眼里是一个符号,而实际上它是Ellipsis对象的别名,
而Ellipsis对象又是elipsis类的单一实例.
它可以作为切片规范的一部分,

2.4.4 给切片赋值
如果把切片放在赋值语句的左边,或把它作为del操作的对象,
我们就可以对序列进行嫁接,切除或就地修改操作.
l = list(range(10))
l --> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
l[2:5] = [20, 30]
l --> [0, 1, 20, 30, 5, 6, 7, 8, 9]
del l[5:7]
l --> [0, 1, 20, 30, 5, 8, 9]
l[3::2] = [11, 22]
l --> [0, 1, 20, 11, 5, 22, 9]
l[2:5] = 100
报错:如果赋值的对象是一个切片,那么赋值语句的右侧必须是可迭代对象.
即便只有单独一个值,也要把它转换成可迭代的序列
l[2:5] = [100]
l --> [0, 1, 100, 22, 9]

2.5 对序列使用+和*
通常+两侧的序列由想同类型的数据所构成,
在拼接的过程中,两个被操作的序列都不会被修改,
Python会新建一个包含同样类型数据的序列来作为拼接的结果
如果想要把一个序列几份然后再拼接起来,更快捷的做法是
把这个序列乘以一个整数.同样,这个操作会产生一个新序列
l = [1, 2, 3]
l * 5 -> [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,2, 3]
5 * 'abcd' -> 'abcdabcdabcdabcdabcd'
+和*都遵循这个规律,不修改原有的操作对象,而是构建一个全新的序列
如果在a*n这个语句中,序列a里的元素是对其他可变对象的引用的话,
你就需要格外注意了,
因为这个式子的结果可能会出乎意料.
比如,my_list = [[]] * 3来初始化一个由列表组成的列表,
但是得到的列表里包含的3个元素其实是3个引用,
而这3个引用指向的都是同一个列表
注意:
board = []
for i in range(3):
    row = ['_'] * 3 # 注意赋值语句在迭代内外的区别
    board.append(row)
每次迭代中都新建了一个列表,作为新的一行row追加到board

2.6 序列的增量赋值
+= --> __iadd__就地加法 --> 退一步,__add__
a += b
如果实现了__iadd__方法,就会调用这方法.
同时对可变序列,如list,bytearray和array.array来说,a会就地改动,
就像调用了a.extand(b)一样.
如果没有实现,a += b --> a = a + b:
首先计算a + b,得到一个新的对象,然后赋值给a,
可变序列一般都实现了__iadd__方法,因此+=是就地加法.id,内存位置不变
而不可变序列根本就不支持这个操作,对这个方法的实现也无从谈起
上述同样适用于*= --> __imul__
对不可变序列进行重复拼接操作的话,效率会很低,
因为每次都有一个新对象,而解释器需要把原来对象中的元素先赋值到新对象里,
然后追加新的元素.
str除外,CPython做了优化.
为str初始化内存的时候,程序会为它留出额外的可扩展空间,
因此进行增量操作的时候,并不会涉及赋值原有字符串到新位置这类操作.

一个关于+=的谜题
t = (1, 2, [30, 40])
t[2] += [50, 60]

不要把可变对象放在元组里面
增量赋值不是一个原子操作
查看Python的字节码并不难,而且他对我们了解代码背后的运行机制很有帮助
dis.dis('s[a] += b')

2.7 list.sort方法和内置函数sorted
list.sort方法会就地排序列表,也就是说不会把原列表赋值一份,返回值是None,
Python惯例:如果一个函数或者方法对对象进行的是就地改动,那么它就应该返回None,
好让调用者知道传入的参数发生了变化,而且并未产生新的对象.
random.shuffle也遵守这个惯例

用返回None来表示就地改动这个惯例有个弊端,
那就是调用者无法将其串联起来.
而返回一个新对象的方法(比如说str里的所有方法)则正好相反,
他们可以串联起来调用,从而形成连贯接口(fluent interface)
与list.sort相反的是内置函数sorted,
它会新建一个列表作为返回值.这个方法可以接受任何形式的可迭代对象作为参数,
甚至包括不可变序列或生成器.不管sorted接受的是什么参数,最后都返回一个列表.
不管是list.sort还是sorted函数,都有两个可选的关键字参数
reverse
如果被设定为True,被排序的序列里的元素会以降序输出.默认值为False
key
一个只有一个参数的函数,这个函数会被用在序列里的每一个元素上,
所产生的结果将是排序算法依赖的对比关键字.
比如说,在对一些字符串排序时,可以用key=str.lower来实现忽略大小写的排序,
或者使用key=len进行基于字符串长度的排序.
这个参数的默认值是恒等函数(identity function),也就是默认用元素自己的值来排序.
可选参数key还可以在内置函数min()和max()中起作用.
另外,还有些标准库里的函数也接受这个参数,像
itertools.groupby()和heapq.nlargest()等
Python的排序算法Timsort是稳定的,就算两个元素比不出大小,在每次排序的结果里他们的相对位置是固定的.

2.8 用bisect来管理已排序的序列
bisect模块包含两个主要函数,
bisect和insort,
两个函数都利用二分查找算法在有序序列中查找或插入元素.
2.8.1用bisect来搜索
bisect(haystack, needle)在haystack(干草垛)里搜索needle(针)的位置,
该位置满足的条件时,把needle插入这个位置之后,haystack还能保持升序.
也就是说这个函数返回的位置前面的值,都小于或等于needle的值.
其中haystack必须是一个有序的序列.你可以先用bisect(haystack, needle)
查找位置index,在用haystack.insert(index, needle)来插入新值.
但是也可以用insort来一步到位,并且后者的速度更快一些.
bisect_test.py
bisect函数是bisect_right函数的别名与bisect_left
区别在于:bisect_left返回的插入位置是原序列中跟被插入元素相等的元素的位置,也就是新元素会被放置与它相等的元素的前面,而bisect_right返回的则是跟他相等的元素之后的位置.
对于那些值相等但是形式不同的数据类型,结果是不一样的.

实例:根据一个分数,找到它所对应的成绩:
def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):
    i = bisect(breakpoints, score)
    return grades[i]
bisect可以在很长的有序序列中作为index的替代,来更快地查找一个元素的位置

2.8.2 用bisect.insort插入新元素
bisect.insort为了得到一个有序序列之后,保持它的有序.
insort(seq, item)把变量item插入到序列seq中,并能保持seq的升序顺序
insort_test.py
inosrt跟bisect一样,有lo和hi两个可选参数用来控制查找的范围.
它也有个变体叫做insort_left,这个变体在背后用的是bisect_left
目前所提到的内容都不仅仅是对列表或元组有效,还可以应用于几乎所有的数据类型上.
有时候因为列表是在是太方便了,有可能过度使用

2.9 当列表不是首选时
要存放1000万个浮点数的话,数组(array)的效率会高得多,因为数组在背后存的并不是float对象,而是数学的机器翻译,也就是字节表述.
这一点就跟C语言中的数组一样.再比如说,如果需要频繁对序列做出先进后出的操作,
deque(双端序列)的速度应该会更快
如果在代码中,包含操作(比如检查一个元素是否出现在一个集合中)的频率很高,
用set(集合)会更合适.set专为检查元素是否存在做过优化.但是它不是序列,因为set是无序的.

2.9.1 数组
如果我们需要一个只包含数字的列表,那么array.array比list跟高效.
数组支持所有跟可变序列有关的操作,包括.pop,.insert和.extend
另外,数组还提供了从文件读取和存入文件的更快的方法,如.frombytes和.tofile
Python数组跟C语言数组一样精简.创建数组需要一个类型码,这个类型码用来表示在底层的C语言应该存放怎样的数据类型.
比如b类型码代表的是有符号的字符(signed char),因此array('b')创建出的
数组就只能存放一个字节大小的整数,范围从-128到127.
Python不会允许你在数组里存放除指定类型之外的数据.
array_test.py
另外一个快速序列化数字类型的方法是使用pickle模块.
pickle.dump处理浮点数组的速度几乎跟array.tofile一样快.
不过前者可以处理几乎所有的内置数字类型,包含复数,嵌套集合,甚至用户自定义的类.前提是这些类没有什么特别复杂的实现.
从Python3.4开始,数组类型不再支持诸如list.sort()这种就地排序方法.
要给数组排序的话,就得用sorted函数新建一个数组:
a =array.array(a.typecode, sorted(a)) # typecode代表数组在C语言中的类型
想要在不打乱次序的情况下为数组添加新的元素,bisect.insort还是能派上用场.

2.9.2 内存试图
memoryview是一个内置类,它能让用户在不复制内容的情况下操作同一个数组的不同切片.
memoryview的概念收到了NumPy的启发.
内存视图其实是泛化和去数学化的NumPy数组.
它让你在不需要复制内容的前提下,在数据结构之间共享内存.
其中数据结构可以是任何形式,比如PIL图片,SQLite数据库和NumPy数组,等等.
这个功能在处理大型数据集合的是否非常重要.
memoryview.cast的概念跟数组模块类似,能用不同的方式读写同一块内存数据,
而且内容字节不会随意移动.这听上去又跟C语言中类型转换的概念差不多.
memoryview.cast会把同一块内存里的内容打包成一个全新的memoryview对象给你.
memoryview_test.py
利用memoryview和struct来操作二进制序列

2.9.3 NumPy和SciPy
凭借着NumPy和SCIPy提供的高阶数组和矩阵操作,
Python成为科学计算应用的主流语言.
NumPy实现了多维同质数组(homogeneous array)和矩阵,
这些数据结构不但能处理数字,还能存放其他由用户定义的记录.
通过NumPy,用户能对这些数据结构里的元素进行高效的操作.
SciPy是基于NumPy的另一个库,
它提供了很多跟科学计算有关的算法,
专为线性代数,数值积分和统计学而设计.
SciPy的高效和可靠性归功于其背后的C和Fortran代码,
而这些跟计算有关的部分都源自于Netlib库.
换句话说,SciPy把基于C和Fortran的工业级数学计算功能用交互式且高度抽象的Python包装起来,让科学家如鱼得水
numpy_test.py
NumPy和SciPy的安装可能会比较费劲.
可以安装Anocoda,Enthought,Canopy,WinPython等等.
在Debian或Ubuntu上面:sudo apt-get install python-numpy python-scipy
以上的内容仅仅是九牛一毛.NumPy和SciPy都是异常强大的库,也是其他一些很有用的工具的基石.
Pandas和Blaze数据分析库就是以他们为基础,提供了高效的且能存储非数值类型数据的数组类型,和读写常见数据文件格式(例如csv,xls,SQL转储和HDF5)的功能.

2.9.4 双向队列和其他形式的队列
利用.append和.pop方法,我们可以把列表当做栈或者队列来用,就能模拟栈的"先进先出"的特点.
但是删除列表的第一个元素(抑或是在第一个元素之前添加一个元素)之类的操作是很耗时的,因为这些操作会牵扯到移动列表里的所有元素.
collections.deque类(双向队列)是一个线程安全,可以快速从两端添加或者删除元素的数据类型.
双向队列实现了大部分列表所拥有的方法,也有一些额外的符合自身设计的方法,
比如popleft和rotate.
但是为了实现这些方法,双向队列也付出了一些代价,从队列中间删除元素的操作会慢一些,因为它只对在头尾的操作进行了优化
append和popleft都是原子操作,也就说是deque可以在多线程程序中安全地都当做先进先出的栈使用,而使用者不需要担心资源锁的问题
a_list.pop(p)这个操作只能用于列表,双向队列的这个方法不接受参数

queue也有对队列的实现.
提供了同步(线程安全)类Queue,LifoQueue和PriorityQueue,
不同的线程可以利用这些数据类型来交换信息.
这三个类的构造方都有一个可选参数maxsize,它接受正整数作为输入值,
用来限定队列的大小.但是在满员的时候,这些类不会扔掉旧的元素来腾出位置.
相反,如果队列满了,它就会被锁住,直到另外的线程移除了某个元素而腾出了位置.
这一特性让这些类很适合用来控制活跃线程的数量
multiprocessing
这个包实现了自己的Queue,它跟queue.Queue类似,是设计给进程间通信用的.
同时还有一个专门的multiprocessing.JoinableQueue类型,可以让任务管理变得更方便.
asyncio
里面有Queue,LifoQueue,PriorityQueue和JoinableQueue,
这些类受到queue和multiprocessing模块的影响,但是为异步编程里的任务管理提供了专门的便利
heapq
跟上面三个模块不同的是,heapq没有队列类,而是提供了heappush和heappop方法,
让用户可以把可变序列当做堆队列或者优先队列来使用.

2.10本章小结
要想写出准确,高效和地道的Python代码,对标准库里的序列类型的掌握是不可或缺的.
Python序列类型最常见的分类就是可变和不可变序列.但另外一种分类方式也很有用,
那就是把它们分为扁平序列和容器序列.前者的体积更小,速度更快而且用起来更简单,但是它只能保存一些原子性的数据,比如数字,字符和字节.
容器序列则比较灵活,但是当容器序列遇到可变对象时,用户就需要格外小心了,
因为这种组合时长会搞出一些"意外",特别是带嵌套的数据结构出现时,用户要多费一些心思来保证代码的正确.
列表推导和生成器表达式则提供了灵活构建和初始化序列的方式,这两个工具都异常强大.
如果你还不能熟练地使用他们,可以专门花时间练习一下.
元组在Python里扮演了两个角色,它既可以用作无名称的字段的记录,又可以看作不可变的列表.当元组被当作记录来用的时候,拆包是最安全可靠地从元组里
提取不同字段信息的方式.新引入的*句法让元组拆包的
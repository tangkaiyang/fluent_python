容器序列
list,tuple和collecitons.deque能存放不同类型的数据
扁平序列
str,bytes,bytearray,memoryview和array.array只能容纳一种类型.
容器徐磊存放的是它们所包含的任意类型的对象的引用,
而扁平序列里存放的是值而不是引用.
扁平序列其实是一段连续的内存空间.更加紧凑,只能存放诸如字符,字节和数值这种基础类型

可变序列(MutableSequence):list,bytearray,array.array,collections.deque和memoryview
不可变序列(Sequence):tuple,str和bytes

Python会忽略代码里的[], {}和()中的换行,
列表推导式不会再有变量泄露的问题

笛卡尔积
笛卡尔积是一个列表,列表里的元素是由输入的可迭代类型的元素对构成的元组,
因此笛卡尔积列表的长度等于输入变量的长度的乘积
colors = ['black', 'white']
sizes = ['S', 'M', 'L']
tshirts = [(color, size) for color in colors for size in sizes]
更换输出顺序只需要调整从句顺序,for循环嵌套顺序一致
列表推导式-->生成列表
生成器表达式-->其他类型的序列
列表推导式可以初始化元组,数组或者其他序列类型,
但是生成器表达式是更好的选择
因为生成器表达式遵守了迭代器协议,可以逐个产出元素,而不是建立一个完整的列表,
然后再把这个列表传递到某个构造函数里.节省了内存
[] --> ()
实例2.5
用生成器表达式初始化元组和数组
symbols = '$fdj'
tuple(ord(symbol) for symbol in symbols)
import array
array.array('I', (ord(symbol) for symbol in symbols))
array(...)
如果生成器表达式是一个函数调用过程中的唯一参数,那么不需要额外用括号围起来
array的构造方法需要两个参数,因此括号是必须的.array构造方法的第一个参数指定了数组中数字的存储方式

2.3元组不仅仅是不可变的列表
还可以用于没有字段名的记录
2.3.1 元组和记录
元组其实是对数据的记录:
元组中的每个元素都存放了记录中一个字段的数据,外加这个字段的位置.正是这个位置信息给数据赋予了意义.
2.3.2 元组拆包
元组拆包可以应用到任何可迭代对象上,
唯一的硬性要求是,被可迭代对象中的元素数量必须要跟接受这些元素的元组的空档数一致.
除非我们用*表示忽略多余的元素,
最好辨认的元组拆包形式是平行赋值,也就是说把一个可迭代对象里的元素,一并赋值到由对应的变量组成的元组中.
lax_coordinates = (33.9425, -118.408056)
latitude, longitude = lax_coordinates # 元组拆包
不使用中间变量交换两个变量的值:
b, a = a, b
用*运算符把一个可迭代对象拆开作为函数的参数:
divmod(20, 8) -> (2, 4)
t = (20, 8)
divmod(*t) -> (2, 7)
quotient, remainder = divmod(*t)
元组拆包让一个函数可以用元组的形式返回多个值,然后调用函数的代码就能轻松地接受这些返回值.
如:os.path.split()函数会返回以路径和最后一个文件名组成的元组
(path, last_part)
import os
_, filename = os.path.split('/home/luciano/.ssh/idrsa.pub')
filename -> 'idrsa.pub'
在进行拆包的时候,不总对元组里所有的数据都感兴趣,
_占位符能帮助处理这种情况
注意:如果做的是国际化软件,那么_可能就不是一个理想的占位符,
因为它也是gettext.gettext函数的常用别名,
元组拆包中使用*也可以帮助我们把注意力集中在元组的部分元素上.
在Python中,函数用*args来获取不确定数量的参数.
在Python3中,这个概念被扩展到了平行赋值中:
a, b, *rest = range(5)
a, b, rest --> (0, 1, [2, 3, 4])
a, b, *rest = range(3)
a, b, rest --> (0, 1, [2])
a, b, *rest = range(2)
a, b, rest --> (0, 1, [])
在平行赋值中,*前缀只能用在一个变量名前面,但是这个变量可以出现在赋值表达式的任意位置:
a, *body, c, d = range(5)
a, body, c, d --> (0, [1, 2], 3, 4)
*head, b, c, d = range(5)
head, b, c, d --> ([0, 1], 2, 3, 4)

2.3.3 嵌套元组拆包
接受表达式的元组可以是嵌套式的,
例如(a, b, (c, d)).
只要这个接受元组的嵌套结构符号表达式本身的嵌套结构,就可以做出正确的对应.
在Python3之前,元组可以作为形参放在函数声明中,
例如def fn(a, (b, c), d):
然而Python3不再支持这种格式,
我们时常会需要给记录中的字段命名.
namedtuple函数的出现帮我们结局了这问题

2.3.4 具名元组
collections.namedtuple是一个工厂函数,
它可以用来构建一个带字段名的元组和一个有名字的类
这个带名字的类对调试程序有很大帮助
用namedtuple构建的类的实例锁消耗的内存跟元组是一样的,
因为字段名都被存在对应的类里面.
这个实例跟普通的对象实例比起来要小一些,因Python不会用__dict__来存放这些实例的属性.
例:新建Card类:
Card = collections.namedtuple('Card', ['rank', 'suit'])

创建一个具名元组需要两个参数,一个是类名,另一个是类的各个字段的名字.
后者可以是由数个字符组成的可迭代对象,或者由空格分隔开的字段名组成的字符串
存放在对应字段里的数据要以一串参数的形式传入到构造函数中(注意,元组的构造函数却只接受单一的可迭代对象)
你可以通过字段名或者位置来获取一个字段的信息

除了从普通元组那里继承来的属性之外,具名元组还有一些自己专用的属性.
_fields类属性,类方法__make(iterable)和实例方法_asdict()

_fields属性是一个包含这个类所有字段名称的元组
用_make()通过接受一个可迭代对象来生成这个类的一个实例,
它的作用跟City(*delhi_data)是一样的
_asdict()把具名元组以collections.OrderedDict的形式返回,
我们可以利用他来把元组里的信息友好地呈现出来.

2.3.5 作为不可变列表的元组
除了跟增减元素相关的方法之外,元组支持列表的其他所有方法.
还有一个例外,元组没有__reversed__方法
这个方法只是个优化而已,reversed(my_tuple)这个用法在没有__reversed__的情况下也是合法的.


2.4 切片
2.4.1 为什么切片和区间会忽略最后一个元素
下标从0作为起始的好处:
当只有最有一个位置信息时,我们也可以快速看出切片和区间里有几个元素:
range(3)和my_list[:3]都返回3个元素
当起止位置信息都可见时,我们可以快速计算出切片和区间的长度,
用后一个数减去第一个下标(stop-start)即可
这样做也让我们可以利用任意一个小标来把序列分割成不重叠的两部分,
只要写成my_list[:x]和my_list[x:]就可以了
2.4.2 对对象进行切片
可以用s[a: b: c]形式对s在a和b之间以c为间隔取值.c可以为负,意味着反向取值.
s = 'bicycle'
s[::3] --> 'bye'
s[::-1] --> 'elcyclib'
s[::-2] --> 'eccb'
对seq[start:stop:step]进行求值的时候,
Python会调用seq.__getitem__(slice(start, stop, step)).

2.4.3 多维切片和省略
[]运算符里还可以使用以逗号分开的多个索引或者是切片,
要正确处理这种[]运算符的话,对象的特殊方法__getitem__和__setitem__
需要以元组的形式来接受a[i, j]中的索引.
也就是说要得到a[i, j]的值,Python会调用a.__getitem__((i, j))
Python内置的序列类型都是一维的,因此它们只支持单一的索引,成对出现的索引是没有用的.
省略(ellipsis)的正确书写方法是三个英文句号...,
而不是Unicode码位U+2026表示的半个省略号.
省略在Python解释器眼里是一个符号,而实际上它是Ellipsis对象的别名,
而Ellipsis对象又是elipsis类的单一实例.
它可以作为切片规范的一部分,

2.4.4 给切片赋值
如果把切片放在赋值语句的左边,或把它作为del操作的对象,
我们就可以对序列进行嫁接,切除或就地修改操作.
l = list(range(10))
l --> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
l[2:5] = [20, 30]
l --> [0, 1, 20, 30, 5, 6, 7, 8, 9]
del l[5:7]
l --> [0, 1, 20, 30, 5, 8, 9]
l[3::2] = [11, 22]
l --> [0, 1, 20, 11, 5, 22, 9]
l[2:5] = 100
报错:如果赋值的对象是一个切片,那么赋值语句的右侧必须是可迭代对象.
即便只有单独一个值,也要把它转换成可迭代的序列
l[2:5] = [100]
l --> [0, 1, 100, 22, 9]

2.5 对序列使用+和*
通常+两侧的序列由想同类型的数据所构成,
在拼接的过程中,两个被操作的序列都不会被修改,
Python会新建一个包含同样类型数据的序列来作为拼接的结果
如果想要把一个序列几份然后再拼接起来,更快捷的做法是
把这个序列乘以一个整数.同样,这个操作会产生一个新序列
l = [1, 2, 3]
l * 5 -> [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,2, 3]
5 * 'abcd' -> 'abcdabcdabcdabcdabcd'
+和*都遵循这个规律,不修改原有的操作对象,而是构建一个全新的序列
如果在a*n这个语句中,序列a里的元素是对其他可变对象的引用的话,
你就需要格外注意了,
因为这个式子的结果可能会出乎意料.
比如,my_list = [[]] * 3来初始化一个由列表组成的列表,
但是得到的列表里包含的3个元素其实是3个引用,
而这3个引用指向的都是同一个列表
注意:
board = []
for i in range(3):
    row = ['_'] * 3 # 注意赋值语句在迭代内外的区别
    board.append(row)
每次迭代中都新建了一个列表,作为新的一行row追加到board

2.6 序列的增量赋值
+= --> __iadd__就地加法 --> 退一步,__add__
a += b
如果实现了__iadd__方法,就会调用这方法.
同时对可变序列,如list,bytearray和array.array来说,a会就地改动,
就像调用了a.extand(b)一样.
如果没有实现,a += b --> a = a + b:
首先计算a + b,得到一个新的对象,然后赋值给a,
可变序列一般都实现了__iadd__方法,因此+=是就地加法.id,内存位置不变
而不可变序列根本就不支持这个操作,对这个方法的实现也无从谈起
上述同样适用于*= --> __imul__
对不可变序列进行重复拼接操作的话,效率会很低,
因为每次都有一个新对象,而解释器需要把原来对象中的元素先赋值到新对象里,
然后追加新的元素.
str除外,CPython做了优化.
为str初始化内存的时候,程序会为它留出额外的可扩展空间,
因此进行增量操作的时候,并不会涉及赋值原有字符串到新位置这类操作.

一个关于+=的谜题
t = (1, 2, [30, 40])
t[2] += [50, 60]

不要把可变对象放在元组里面
增量赋值不是一个原子操作
查看Python的字节码并不难,而且他对我们了解代码背后的运行机制很有帮助
dis.dis('s[a] += b')

2.7 list.sort方法和内置函数sorted
list.sort方法会就地排序列表,也就是说不会把原列表赋值一份,返回值是None,
Python惯例:如果一个函数或者方法对对象进行的是就地改动,那么它就应该返回None,
好让调用者知道传入的参数发生了变化,而且并未产生新的对象.
random.shuffle也遵守这个惯例

用返回None来表示就地改动这个惯例有个弊端,
那就是调用者无法将其串联起来.
而返回一个新对象的方法(比如说str里的所有方法)则正好相反,
他们可以串联起来调用,从而形成连贯接口(fluent interface)
与list.sort相反的是内置函数sorted,
它会新建一个列表作为返回值.这个方法可以接受任何形式的可迭代对象作为参数,
甚至包括不可变序列或生成器.不管sorted接受的是什么参数,最后都返回一个列表.
不管是list.sort还是sorted函数,都有两个可选的关键字参数
reverse
如果被设定为True,被排序的序列里的元素会以降序输出.默认值为False
key
一个只有一个参数的函数,这个函数会被用在序列里的每一个元素上,
所产生的结果将是排序算法依赖的对比关键字.
比如说,在对一些字符串排序时,可以用key=str.lower来实现忽略大小写的排序,
或者使用key=len进行基于字符串长度的排序.
这个参数的默认值是恒等函数(identity function),也就是默认用元素自己的值来排序.
可选参数key还可以在内置函数min()和max()中起作用.
另外,还有些标准库里的函数也接受这个参数,像
itertools.groupby()和heapq.nlargest()等
Python的排序算法Timsort是稳定的,就算两个元素比不出大小,在每次排序的结果里他们的相对位置是固定的.

2.8 用bisect来管理已排序的序列
bisect模块包含两个主要函数,
bisect和insort,
两个函数都利用二分查找算法在有序序列中查找或插入元素.
2.8.1用bisect来搜索
bisect(haystack, needle)在haystack(干草垛)里搜索needle(针)的位置,
该位置满足的条件时,把needle插入这个位置之后,haystack还能保持升序.
也就是说这个函数返回的位置前面的值,都小于或等于needle的值.
其中haystack必须是一个有序的序列.你可以先用bisect(haystack, needle)
查找位置index,在用haystack.insert(index, needle)来插入新值.
但是也可以用insort来一步到位,并且后者的速度更快一些.
bisect_test.py
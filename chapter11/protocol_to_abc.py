# !/usr/bin/env python3
# -*- coding: utf-8 -*-
# @Time     : 2019/4/10 7:08
# @Author   : tangky
# @Site     : 
# @File     : protocol_to_abc.py
# @Software : PyCharm
"""
第11章 接口:从协议到抽象基类
接口:从鸭子类型的代表特征动态协议,
到使接口更明确,能验证实现是否符合规定的抽象基类(Abstract Base Class, ABC)
抽象基类的常见用途:实现接口时作为超类使用.
如何使用注册机制声明一个类实现了某个接口,而不进行子类化操作.
说明如何让抽象基类自动"识别"任何符合接口的类--不进行子类化或注册
不建议编写抽象基类,容易过度设计
抽象基类与描述符和元类一样,适用于构建框架的工具,
因此,只有少数Python开发者编写的抽象基类不会对用户施加不必要的限制,让他们做无用功

11.1 Python文化中的接口和协议
按照定义,受保护的属性和私有属性不在接口中:即便"受保护的"属性也只是采用命名约定实现的(单个前导下划线);私有属性可以轻松地访问
另一方面,不要觉得把公开数据属性放入对象的接口中有什么不妥,因为如果需要,
总能实现读值方法和设值方法,把数据属性变成特性,

接口的补充定义:对象公开方法的子集,让对象在系统中扮演特定的角色
接口是实现特定角色的方法集合
协议与继承没有关系.
一个类可能会实现多个接口,从而让实例扮演多个角色
协议是接口,但不是正式的(只由文档和约定定义),因此协议不能像正式接口那样施加限制
(抽象基类对接口一致性的强制).
允许一个类只实现部分接口

11.2 Python喜欢序列
Python数据模型的哲学是尽量支持基本协议.
对序列来说,即便是最简单的实现,Python也会力求做到最好
示例11-3中的Foo类,没有继承abc.Sequence,而且只实现了序列协议的一个方法:__getitem__
"""
# 示例11-3 定义__getitem__方法,只实现了序列协议的一部分,这样就足够访问元素,迭代和使用in运算符了
# class Foo:
#     def __getitem__(self, pos):
#         return range(0, 30, 10)[pos]
# f = Foo()
# print(f[1])
# for i in f:print(i)
# print(20 in f)
# print(15 in f)
"""
Python会特殊对待看起来像是序列的对象.
Python中的迭代是鸭子类型的一种极端形式:为了迭代对象,解释器会尝试调用两种不同的方法
协议的动态本性

11.3 使用猴子补丁在运行时实现协议
洗牌:random.shuffle函数(就地打乱序列)
如果遵守既定协议,很有可能增加利用现有的标准库和第三方代码的可能性,这得益于鸭子类型
shuffle函数要调换集合中元素的位置,而FrenchDeck只实现了不可变的序列协议.
可变的序列还必须提供__setitem__方法
Python是动态语言,因此我们可以在运行时修正这个问题,甚至还可以在交互式控制台中,
示例11-6 为FrenchDeck打猴子补丁,把它变成可变的,让random.shuffle能处理
def set_card(deck, position, card):
    deck._cards[position] = card
# deck可以替换为self,Python方法说到底都是普通函数,把第一个参数命名为self只是约定
FrenchDeck.__setitem__ = set_card
shuffle(deck)
这里的关键是,set_card函数要知道deck对象有一个名为_cards的属性,而且_cards的值必须是可变
序列.然后,我们把set_card函数赋值给特殊方法__setitem__,从而把他依附到FrenchDeck类上.
这种技术叫做猴子补丁:在运行时修改类或模块,而不改动源码.
猴子补丁很强大,但是打补丁的代码与要打补丁的程序耦合十分紧密,而且往往要处理隐藏和没有文档的部分
协议是动态的:random.shuffle函数不关心参数的类型,只要那个对象实现了部分可变序列协议即可.
即便对象一开始没有所需方法也没关系,后来再提供也行
"鸭子类型":对象的类型无关紧要,只要实现了特定的协议即可

11.4 Alex Martelli的水禽
参照水禽的分类学演化,在鸭子类型的基础上增加
白鹅类型(goose typing),只要cls是抽象基类,即cls的元类是abc.ABCMeta,就可以使用isinstance(obj, cls)
Python的抽象基类还有一个重要的实用优势:可以使用register类方法在终端用户的代码中把某个类"声明"为一个抽象基类的"虚拟"子类(为此,被注册的类必须满足抽象基类对方法名称和签名的要求,
最重要的是要满足底层语义契约;但是,开发哪个类时不用了解抽象基类,更不用继承抽象基类).
这大大地打破了严格的强耦合,与面向对象编程人员掌握的知识有很大出入,因此使用继承时要小心
有时,为了让抽象基类识别子类,甚至不用注册
class Struggle:
    def __len__(self): return 23
from collections import abc
isinstance(Struggle(), abc.Sized)--> True
无需注册,abc.Sized也能把Struggle识别为自己的子类,
只要实现了特殊方法__len__即可(要使用正确的句法和语义实现,前者要求没有参数,
后者要求返回一个非负整数,指明对象的长度;如果不使用规定的句法和语义实现特殊方法,会导致非常严重的问题)

继承抽象基类很简单,只需要实现所需的方法,
能通过注册虚拟子类实现
然而,即便是抽象基类,也不能滥用isinstance检查,用多了可能导致代码异味,
即表明面向对象设计得不好.在一连串if/elif/elif中使用isinstance做检查,然后根据对象的类型
执行不同的操作,通常不是好的做法;此时应该使用多态,
即采用一定的方式定义类,让解释器把调用分派给正确的方法,而不适用if/elif/elif块硬编码分派逻辑
具体使用时,上述建议有一个常见的例外:
有些Python API接受一个字符串或字符串序列;如果只有一个字符串,可以把它放到列表中,从而简化处理.
因此字符串是序列类型,所以为了把它和其他不可变序列区分开,最简单的方式是使用isinstance(x, str)检查
抽象基类用于封装框架引入的一般性概念和抽象的,例如"一个序列"和"一个确切的数".
基本上不需要自己编写新的抽象基类,只要正确使用现有的抽象基类,

11.5 定义抽象基类的子类

"""
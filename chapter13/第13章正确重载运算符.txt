第13章 正确重载运算符
运算符重载的作用是让用户定义的对象使用中缀运算符(如+和|)或一元运算符(如-和~)
宽泛一些:在Python中,函数调用(()),属性访问(.)和元素访问/切片([])也是运算符,
不过本章只讨论一元运算符和中缀运算符

Python如何处理中缀运算符中不同类型的操作数
使用鸭子类型或显示类型检查处理不同类型的操作数
中缀运算符如何表明自己无法处理操作数
众多比较运算符(如==,>,<=,等等)的特殊行为
增量赋值运算符(如+=)的默认处理方式和重载方法

13.1 运算符重载基础
不能重载内置类型的运算符
不能新建运算符,只能重载现有的
某些运算符不能重载------is,and,or和not(不过位运算符&,|和~可以)
==由__eq__方法支持
13.2 一元运算符
-(__neg__)一元取负运算符
+(__pos__)一元取正运算符.通常x == +x,但也有一些例外(decimal.Decimal精度相关/collections.Counter正负相关)
~(__invert__)对整数按位取反,定义为~x==-(x+1)
此外:
内置的abs()也为一元运算符对应__abs__
支持一元运算符很简单,只需要实现相应的特殊方法.
这些特殊方法只有一个参数,self
然后,使用符合所在类的逻辑实现.
不过,要遵守运算符的一个基本规则:始终返回一个新对象(不能修改self,要创建并返回合适类型的新实例)

13.3 重载向量加法运算符+
__add__方法
实现一元运算符和中缀运算符的特殊方法一定不能修改操作数.
使用这些运算符的表达式期待结果是新对象.只有增量赋值表达式可能会修改第一个操作数(self)
示例13-6 如果左操作数是Vector之外的对象,上述__add__无法处理
为了支持涉及不同类型的运算,Python为中缀运算符特殊方法提供了特殊的分派机制.
对表达式a+b来说,会执行的步骤:
1)如果a有__add__方法,而且返回值不是NotImplemented,调用a.__add__(b),然后返回结果
2)如果a没有__add__方法,或者调用__add__方法返回NotImplemented,检查b有没有__radd__方法,
如果有,而且没有返回NotImplemented,调用b.__radd__(a),然后返回结果
3)如果b没有__radd__方法,或者调用__radd__方法返回NotImplemented,抛出TypeError,并在错误消息中指明操作数类型不支持
__radd__是__add__的"反射"(reflected)版本或者"反向"(reversed)版本.
或"右向"(right)特殊方法
因此还需实现__radd__方法(后备机制)
别把NotImplemented和NotImplementedError搞混了.
前者是特殊的单例值,如果中缀运算符特殊方法不能处理给定的操作数,那么要把它返回(return)给解释器.
而NotImplementedError是一种异常,抽象类中的占位方法把它抛出(raise),提醒子类必须覆盖
如果中缀运算符方法抛出异常,就终止了运算符分派机制.
对TypeError来说,通常最好将其捕获,然后返回NotImplemented.这样,解释器会尝试调用反向运算符方法,如果操作数
是不同的类型,对调之后,反向运算符可能会正确计算

13.4 重载标量乘法运算符*
标量积(scalar product)
元素级乘法(elementwise multiplication)
两个向量的点积(dot product)
Python3.5开始@记号可以用作中缀点积运算符:对应的特殊方法为__matmul__,__rmatmul__和__imatmul__,名称取自"matrix multiplication"(矩阵乘法)
实现__mul__和__rmul__
decimal.Decimal没有把自己注册为numbers.Real的虚拟子类.因此,Vector类不会处理decimal.Decimal数字


13.5 众多比较运算符
Python解释器对众多比较运算符(==,!=,>,<,>=,<=)的处理与前文类似,不过在两个方面有重大区别
正向和反向调用使用的是同一系列方法.
对==和!=来说,如果反向调用失败,Python会比较对象的ID,而不抛出TypeError
__eq__(equal:==)
__ne__(not equal:!=)
__gt__(greater than:>)
__lt__(less than:<)
__ge__(greater than or equal:>=)
__le__(less than or equal:<=)
Python3之后的比较运算符机制改变:
对于__ne__,现在返回的结果是对__eq__结果取反.

Python3文档的缺陷(缺陷现已修正)

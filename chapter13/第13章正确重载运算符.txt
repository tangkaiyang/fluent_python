第13章 正确重载运算符
运算符重载的作用是让用户定义的对象使用中缀运算符(如+和|)或一元运算符(如-和~)
宽泛一些:在Python中,函数调用(()),属性访问(.)和元素访问/切片([])也是运算符,
不过本章只讨论一元运算符和中缀运算符

Python如何处理中缀运算符中不同类型的操作数
使用鸭子类型或显示类型检查处理不同类型的操作数
中缀运算符如何表明自己无法处理操作数
众多比较运算符(如==,>,<=,等等)的特殊行为
增量赋值运算符(如+=)的默认处理方式和重载方法

13.1 运算符重载基础
不能重载内置类型的运算符
不能新建运算符,只能重载现有的
某些运算符不能重载------is,and,or和not(不过位运算符&,|和~可以)
==由__eq__方法支持
13.2 一元运算符
-(__neg__)一元取负运算符
+(__pos__)一元取正运算符.通常x == +x,但也有一些例外(decimal.Decimal精度相关/collections.Counter正负相关)
~(__invert__)对整数按位取反,定义为~x==-(x+1)
此外:
内置的abs()也为一元运算符对应__abs__
支持一元运算符很简单,只需要实现相应的特殊方法.
这些特殊方法只有一个参数,self
然后,使用符合所在类的逻辑实现.
不过,要遵守运算符的一个基本规则:始终返回一个新对象(不能修改self,要创建并返回合适类型的新实例)

13.3 重载向量加法运算符+
__add__方法
实现一元运算符和中缀运算符的特殊方法一定不能修改操作数.
使用这些运算符的表达式期待结果是新对象.只有增量赋值表达式可能会修改第一个操作数(self)
示例13-6 如果左操作数是Vector之外的对象,上述__add__无法处理
为了支持涉及不同类型的运算,Python为中缀运算符特殊方法提供了特殊的分派机制.
对表达式a+b来说,会执行的步骤:
1)如果a有__add__方法,而且返回值不是NotImplemented,调用a.__add__(b),然后返回结果
2)如果a没有__add__方法,或者调用__add__方法返回NotImplemented,检查b有没有__radd__方法,
如果有,而且没有返回NotImplemented,调用b.__radd__(a),然后返回结果
3)如果b没有__radd__方法,或者调用__radd__方法返回NotImplemented,抛出TypeError,并在错误消息中指明操作数类型不支持
__radd__是__add__的"反射"(reflected)版本或者"反向"(reversed)版本.
或"右向"(right)特殊方法
因此还需实现__radd__方法(后备机制)
别把NotImplemented和NotImplementedError搞混了.
前者是特殊的单例值,如果中缀运算符特殊方法不能处理给定的操作数,那么要把它返回(return)给解释器.
而NotImplementedError是一种异常,抽象类中的占位方法把它抛出(raise),提醒子类必须覆盖
如果中缀运算符方法抛出异常,就终止了运算符分派机制.
对TypeError来说,通常最好将其捕获,然后返回NotImplemented.这样,解释器会尝试调用反向运算符方法,如果操作数
是不同的类型,对调之后,反向运算符可能会正确计算

13.4 重载标量乘法运算符*
标量积(scalar product)
元素级乘法(elementwise multiplication)
两个向量的点积(dot product)
Python3.5开始@记号可以用作中缀点积运算符:对应的特殊方法为__matmul__,__rmatmul__和__imatmul__,名称取自"matrix multiplication"(矩阵乘法)
实现__mul__和__rmul__
decimal.Decimal没有把自己注册为numbers.Real的虚拟子类.因此,Vector类不会处理decimal.Decimal数字


13.5 众多比较运算符
Python解释器对众多比较运算符(==,!=,>,<,>=,<=)的处理与前文类似,不过在两个方面有重大区别
正向和反向调用使用的是同一系列方法.
对==和!=来说,如果反向调用失败,Python会比较对象的ID,而不抛出TypeError
__eq__(equal:==)
__ne__(not equal:!=)
__gt__(greater than:>)
__lt__(less than:<)
__ge__(greater than or equal:>=)
__le__(less than or equal:<=)
Python3之后的比较运算符机制改变:
对于__ne__,现在返回的结果是对__eq__结果取反.

Python3文档的缺陷(缺陷现已修正)

13.6 增量赋值运算符
示例13-15 增量赋值不会修改不可变目标,而是新建实例,然后重新绑定
如果一个类没有实现就地运算符,增量赋值运算符只是
语法糖:a += b的作用与a = a + b完全一样.对不可变类型来说,这是预期的行为,而且,如果定义了
__add__方法的话,不用编写额外的代码, += 就能使用
然而,如果实现了就地运算符方法,例如__iadd__,计算a += b的结果时会调用就地运算符方法.
这种运算符的名称表明,他们会就地修改左操作数,而不会创建新对象作为结果
不可变类型,如Vector类,一定不能实现就地特殊方法
注意,与+相比,+=运算符对第二操作数更宽容.+运算符的两个操作数必须是相同类型,
而+=的情况更明确,因为就地修改左操作数,所以结果的类型是确定的
通过观察内置list类型的工作方式:
my_list + x只能用于把两个列表加到一起,而my_list += x 可以使用右边可迭代对象x中的元素扩展左边的列表.list.extend()的行为也是这样的,它的参数可以是任何可迭代对象
示例13-18 bingoaddable.py:AddableBingoCage扩展BingoCage,支持+和+=
就地运算符的原理
__add__:调用AddableBingoCage构造方法构建一个新实例,作为结果返回
__iadd__:把修改后的self作为结果返回
一般来说,如果中缀运算符的正向方法(如__mul__)只处理与self属于同一类型的操作数,
那就无需实现对应的反向方法(如__rmul__),因为按照定义,反向方法是为了处理类型不同的操作数

13.7 本章小结
Python对运算符重载施加的一些限制:禁止重载内置类型的运算符,而且限于重载现有的运算符,
不过有几个例外(is,and,or,not)
重载一元运算符,实现__neg__和__pos__
重载中缀运算符,
+:__add__
一元运算符和中缀运算符的结果应该是新对象,并且绝不能修改操作数.
为了支持其他类型,我们返回特殊的NotImplemented值(不是异常),
让解释器尝试对调操作数,然后调用运算符的反向特殊方法(如__radd__)
如果操作数的类型不同,我们要检测出不能处理的操作数.
处理问题的两种方式:一种是鸭子类型:直接尝试执行计算,如果有问题,捕获TypeError异常;
另一种是显示使用isinstance测试,__mul__方法就是这么做的.
鸭子类型更灵活,但是显式检查更能预知结果
如果选择使用isinstance,要小心,不能测试具体类,而要测试numbers.Real抽象基类,
这在灵活性和安全性之间做了很好的折中,因为当前或未来由用户定义的类型可以声明为抽象基类的真实子类或虚拟子类
众多比较运算符.
通过__eq__实现==,
Python在object基类中通过__ne__方法为!=提供了便利的实现.
Python处理这些运算符的方式与>,<,<=,>=稍有不同,具体而言是选择反向方法的逻辑不通,
此外Python还会特殊处理==和!=的后备机制:从不抛出错误,因为Python会比较对象的ID,作最后一搏
增量赋值运算符.Python处理这种运算符的方式是把他们当做常规的运算符加上赋值操作,
即a+=b其实会当成a = a + b处理.这样会始终创建新对象,因此可变类型和不可变类型都能用.
对可变对象来说,可以实现就地特殊方法,例如支持+=的__iadd__方法,然后修改左操作数的值,
对序列类型来说,+通常要求两个操作数属于同一类型,而+=的右操作数往往可以是任何可迭代对象